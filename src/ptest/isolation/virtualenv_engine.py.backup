"""
Virtualenv隔离引擎实现

提供Python虚拟环境隔离功能，包括虚拟环境创建、激活、包管理等
"""

import os
import sys
import venv
import shutil
import subprocess
import time
import uuid
from typing import Dict, Any, List, Optional, Union
from pathlib import Path
import json
from datetime import datetime
import socket
from contextlib import closing

from .base import IsolationEngine, IsolatedEnvironment, ProcessResult
from .enums import EnvironmentStatus, ProcessStatus, IsolationEvent

# 使用框架的日志管理器
from core import get_logger, execute_command

# 使用框架的日志管理器
logger = get_logger("virtualenv_engine")


class VirtualenvEnvironment(IsolatedEnvironment):
    """Virtualenv隔离环境实现"""

    def __init__(
        self,
        env_id: str,
        path: Path,
        isolation_engine: "VirtualenvIsolationEngine",
        config: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(env_id, path, isolation_engine, config or {})
        self.venv_path = path / "venv"
        self.python_path = self.venv_path / "bin" / "python"
        self.pip_path = self.venv_path / "bin" / "pip"
        self.activate_script = self.venv_path / "bin" / "activate"
        self.status = EnvironmentStatus.CREATED
        self._is_active = False

    def create_virtualenv(self) -> bool:
        """创建虚拟环境"""
        try:
            # 确保父目录存在
            self.path.mkdir(parents=True, exist_ok=True)

            # 获取Python解释器路径
            python_exe = self.config.get("python_path", sys.executable)

            # 创建虚拟环境
            builder = venv.EnvBuilder(
                system_site_packages=self.config.get("system_site_packages", False),
                clear=self.config.get("clear", False),
                symlinks=self.config.get("symlinks", True),
                upgrade=self.config.get("upgrade", False),
                with_pip=True,
            )

            logger.info(f"Creating virtual environment at {self.venv_path}")
            builder.create(str(self.venv_path))

            # 验证创建结果
            if not self.python_path.exists():
                raise RuntimeError(f"Python executable not found at {self.python_path}")

            if not self.pip_path.exists():
                raise RuntimeError(f"Pip executable not found at {self.pip_path}")

            self.status = EnvironmentStatus.CREATED
            self._emit_event(IsolationEvent.ENVIRONMENT_CREATED)
            return True

        except Exception as e:
            logger.error(f"Failed to create virtual environment: {e}")
            self.status = EnvironmentStatus.ERROR
            return False

    def activate(self) -> bool:
        """激活虚拟环境"""
        try:
            if not self.venv_path.exists():
                if not self.create_virtualenv():
                    return False

            # 设置环境变量
            env = os.environ.copy()
            env["PATH"] = f"{self.venv_path / 'bin'}:{env.get('PATH', '')}"
            env["VIRTUAL_ENV"] = str(self.venv_path)
            env["PYTHONPATH"] = ""

            # 验证激活
            result = subprocess.run(
                [str(self.python_path), "-c", "import sys; print(sys.prefix)"],
                capture_output=True,
                text=True,
                env=env,
                timeout=10,
            )

            if result.returncode == 0 and str(self.venv_path) in result.stdout.strip():
                self._is_active = True
                self.status = EnvironmentStatus.ACTIVE
                self.activated_at = datetime.now()
                self._emit_event(IsolationEvent.ENVIRONMENT_ACTIVATED)
                return True
            else:
                logger.error("Virtual environment activation verification failed")
                return False

        except Exception as e:
            logger.error(f"Failed to activate virtual environment: {e}")
            self.status = EnvironmentStatus.ERROR
            return False

    def deactivate(self) -> bool:
        """停用虚拟环境"""
        self._is_active = False
        self.status = EnvironmentStatus.INACTIVE
        self.deactivated_at = datetime.now()
        self._emit_event(IsolationEvent.ENVIRONMENT_DEACTIVATED)
        return True

    def execute_command(
        self,
        cmd: List[str],
        timeout: Optional[float] = None,
        env_vars: Optional[Dict[str, str]] = None,
        cwd: Optional[Path] = None,
    ) -> ProcessResult:
        """在虚拟环境中执行命令"""
        start_time = datetime.now()

        try:
            if not self._is_active:
                if not self.activate():
                    return ProcessResult(
                        returncode=1,
                        stderr="Virtual environment not active",
                        command=cmd,
                        start_time=start_time,
                    )

            # 设置环境变量
            env = os.environ.copy()
            env["PATH"] = f"{self.venv_path / 'bin'}:{env.get('PATH', '')}"
            env["VIRTUAL_ENV"] = str(self.venv_path)
            env["PYTHONPATH"] = ""

            # 添加自定义环境变量
            if env_vars:
                env.update(env_vars)

            # 执行命令
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env=env,
                cwd=cwd or self.path,
                timeout=timeout or self.config.get("command_timeout", 300),
            )

            return ProcessResult(
                returncode=result.returncode,
                stdout=result.stdout,
                stderr=result.stderr,
                command=cmd,
                timeout=timeout,
                start_time=start_time,
                end_time=datetime.now(),
            )

        except subprocess.TimeoutExpired:
            return ProcessResult(
                returncode=-1,
                stderr=f"Command timed out after {timeout} seconds",
                command=cmd,
                timeout=timeout,
                start_time=start_time,
                end_time=datetime.now(),
            )
        except Exception as e:
            return ProcessResult(
                returncode=1,
                stderr=str(e),
                command=cmd,
                timeout=timeout,
                start_time=start_time,
                end_time=datetime.now(),
            )

    def install_package(
        self, package: str, version: Optional[str] = None, upgrade: bool = False
    ) -> bool:
        """安装Python包"""
        try:
            package_spec = package
            if version:
                package_spec = f"{package}=={version}"

            cmd = [str(self.pip_path), "install"]
            if upgrade:
                cmd.append("--upgrade")
            cmd.append(package_spec)

            # 设置超时
            timeout = self.config.get("pip_timeout", 300)

            result = self.execute_command(cmd, timeout=timeout)

            if result.success:
                logger.info(f"Successfully installed package: {package_spec}")
                self._emit_event(IsolationEvent.PACKAGE_INSTALLED, package=package_spec)
                return True
            else:
                logger.error(
                    f"Failed to install package {package_spec}: {result.stderr}"
                )
                return False

        except Exception as e:
            logger.error(f"Error installing package {package}: {e}")
            return False

    def uninstall_package(self, package: str) -> bool:
        """卸载Python包"""
        try:
            cmd = [str(self.pip_path), "uninstall", "-y", package]

            result = self.execute_command(
                cmd, timeout=self.config.get("pip_timeout", 300)
            )

            if result.success:
                logger.info(f"Successfully uninstalled package: {package}")
                self._emit_event(IsolationEvent.PACKAGE_INSTALLED, package=package)
                return True
            else:
                logger.error(f"Failed to uninstall package {package}: {result.stderr}")
                return False

        except Exception as e:
            logger.error(f"Error uninstalling package {package}: {e}")
            return False

    def get_installed_packages(self) -> Dict[str, str]:
        """获取已安装的包列表"""
        try:
            cmd = [str(self.pip_path), "list", "--format=json"]
            result = self.execute_command(cmd, timeout=30)

            if result.success:
                packages = json.loads(result.stdout)
                return {pkg["name"]: pkg["version"] for pkg in packages}
            else:
                logger.error(f"Failed to get package list: {result.stderr}")
                return {}

        except Exception as e:
            logger.error(f"Error getting package list: {e}")
            return {}

    def get_package_version(self, package: str) -> Optional[str]:
        """获取特定包的版本"""
        packages = self.get_installed_packages()
        return packages.get(package.lower())

    def allocate_port(self) -> int:
        """分配端口"""
        return self._find_free_port()

    def release_port(self, port: int) -> bool:
        """释放端口"""
        if port in self.allocated_ports:
            self.allocated_ports.remove(port)
            return True
        return False

    def _find_free_port(self) -> int:
        """查找可用端口"""
        with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
            s.bind(("", 0))
            s.listen(1)
            port = s.getsockname()[1]
        self.allocated_ports.append(port)
        return port

    def cleanup(self, force: bool = False) -> bool:
        """清理虚拟环境"""
        try:
            # 先停用环境
            if self._is_active:
                self.deactivate()

            # 删除虚拟环境目录
            if self.venv_path.exists():
                shutil.rmtree(str(self.venv_path), ignore_errors=force)

            # 删除整个环境目录（如果为空）
            if force and self.path.exists() and not any(self.path.iterdir()):
                self.path.rmdir()

            self.status = EnvironmentStatus.CLEANUP_COMPLETE
            self._emit_event(IsolationEvent.ENVIRONMENT_CLEANUP_COMPLETE)
            return True

        except Exception as e:
            logger.error(f"Error cleaning up environment: {e}")
            if not force:
                self.status = EnvironmentStatus.ERROR
                return False
            return True  # 强制清理时即使出错也返回True

    def validate_isolation(self) -> bool:
        """验证隔离有效性"""
        try:
            # 检查虚拟环境路径是否存在
            if not self.venv_path.exists():
                return False

            # 检查Python解释器是否存在
            if not self.python_path.exists():
                return False

            # 检查环境是否激活
            if not self._is_active:
                return False

            return True

        except Exception as e:
            logger.error(f"Error validating isolation: {e}")
            return False

    def create_snapshot(self, snapshot_id: Optional[str] = None) -> Dict[str, Any]:
        """创建Virtualenv环境快照"""
        try:
            if snapshot_id is None:
                timestamp = int(time.time())
                snapshot_id = f"venv_snapshot_{timestamp}_{uuid.uuid4().hex[:8]}"

            self.logger.info(
                f"Creating snapshot {snapshot_id} for Virtualenv environment {self.env_id}"
            )

            snapshot_data = {
                "snapshot_id": snapshot_id,
                "env_id": self.env_id,
                "created_at": datetime.now().isoformat(),
                "env_type": "virtualenv",
                "virtualenv_info": {
                    "venv_path": str(self.venv_path),
                    "python_path": str(self.python_path),
                    "pip_path": str(self.pip_path),
                    "config": self.config,
                    "is_active": self._is_active,
                    "allocated_ports": list(self.allocated_ports),
                    "status": self.status.value,
                    "python_version": self._get_python_version(),
                },
            }

            try:
                installed_packages = self.get_installed_packages()
                snapshot_data["virtualenv_info"]["installed_packages"] = (
                    installed_packages
                )
                self.logger.info(
                    f"Captured {len(installed_packages)} packages in snapshot"
                )
            except Exception as e:
                self.logger.warning(f"Failed to capture package information: {e}")
                snapshot_data["virtualenv_info"]["installed_packages"] = {}

            try:
                config_files = self._backup_config_files()
                snapshot_data["virtualenv_info"]["config_files"] = config_files
            except Exception as e:
                self.logger.warning(f"Failed to backup config files: {e}")
                snapshot_data["virtualenv_info"]["config_files"] = {}

            try:
                custom_scripts = self._backup_custom_scripts()
                snapshot_data["virtualenv_info"]["custom_scripts"] = custom_scripts
            except Exception as e:
                self.logger.warning(f"Failed to backup custom scripts: {e}")
                snapshot_data["virtualenv_info"]["custom_scripts"] = {}

            self._emit_event(IsolationEvent.SNAPSHOT_CREATED, snapshot_id=snapshot_id)

            self.logger.info(f"Successfully created snapshot {snapshot_id}")
            return snapshot_data

        except Exception as e:
            self.logger.error(f"Failed to create snapshot: {e}")
            self._emit_event(IsolationEvent.ERROR_OCCURRED, error=str(e))
            raise

    def _get_python_version(self) -> str:
        try:
            if self.python_path.exists():
                result = subprocess.run(
                    [str(self.python_path), "--version"],
                    capture_output=True,
                    text=True,
                    timeout=10,
                )
                if result.returncode == 0:
                    return result.stdout.strip()
        except Exception:
            pass
        return "unknown"

    def _backup_config_files(self) -> Dict[str, str]:
        config_files = {}
        important_files = [
            "pip.conf",
            "setup.cfg",
            "pyproject.toml",
            "requirements.txt",
            "Pipfile",
        ]

        for filename in important_files:
            file_path = self.path / filename
            if file_path.exists():
                try:
                    with open(file_path, "r", encoding="utf-8") as f:
                        content = f.read()
                    config_files[filename] = content
                except Exception as e:
                    self.logger.warning(f"Failed to read {filename}: {e}")

        return config_files

    def _backup_custom_scripts(self) -> Dict[str, str]:
        scripts = {}
        scripts_dir = self.path / "scripts"

        if scripts_dir.exists() and scripts_dir.is_dir():
            for script_file in scripts_dir.glob("*.py"):
                try:
                    with open(script_file, "r", encoding="utf-8") as f:
                        content = f.read()
                    scripts[script_file.name] = content
                except Exception as e:
                    self.logger.warning(
                        f"Failed to read script {script_file.name}: {e}"
                    )

        return scripts

    def restore_from_snapshot(self, snapshot: Dict[str, Any]) -> bool:
        """从快照恢复Virtualenv环境"""
        try:
            snapshot_id = snapshot.get("snapshot_id")
            self.logger.info(
                f"Restoring Virtualenv environment {self.env_id} from snapshot {snapshot_id}"
            )

            # 调用基类恢复
            if not super().restore_from_snapshot(snapshot):
                return False

            # 恢复Virtualenv特有状态
            virtualenv_info = snapshot.get("virtualenv_info", {})

            # 如果环境被停用，尝试重新激活
            if not self._is_active and self.venv_path.exists():
                self.activate()

            # 重新安装包（如果需要）
            if "installed_packages" in virtualenv_info:
                packages = virtualenv_info["installed_packages"]
                current_packages = self.get_installed_packages()

                # 恢复缺失的包
                for package, version in packages.items():
                    if (
                        package not in current_packages
                        or current_packages[package] != version
                    ):
                        self.logger.info(f"Restoring package {package}=={version}")
                        if not self.install_package(f"{package}=={version}"):
                            self.logger.warning(
                                f"Failed to restore package {package}=={version}"
                            )

            self.logger.info(
                f"Successfully restored Virtualenv environment from snapshot {snapshot_id}"
            )
            return True

        except Exception as e:
            self.logger.error(f"Failed to restore from snapshot: {e}")
            return False

    def delete_snapshot(self, snapshot_id: str) -> bool:
        """删除Virtualenv快照"""
        # 对于Virtualenv，快照只是配置，不需要特殊清理
        return super().delete_snapshot(snapshot_id)

    def list_snapshots(self) -> List[Dict[str, Any]]:
        """列出所有快照"""
        # Virtualenv引擎本身不存储快照，由管理器处理
        return super().list_snapshots()

    def export_snapshot_data(self) -> Dict[str, Any]:
        """导出快照数据"""
        return {
            "env_id": self.env_id,
            "env_type": "virtualenv",
            "venv_path": str(self.venv_path),
            "python_path": str(self.python_path),
            "pip_path": str(self.pip_path),
            "config": self.config,
            "installed_packages": self.get_installed_packages(),
            "allocated_ports": self.allocated_ports,
            "status": self.status.value,
            "created_at": self.created_at.isoformat(),
            "is_active": self._is_active,
        }


class VirtualenvIsolationEngine(IsolationEngine):
    """Virtualenv隔离引擎实现"""

    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.supported_features = [
            "filesystem_isolation",
            "python_package_isolation",
            "process_execution",
            "port_allocation",
        ]
        # 初始化Virtualenv相关配置
        self.default_config = {
            "python_path": sys.executable,
            "system_site_packages": False,
            "clear": False,
            "symlinks": True,
            "upgrade": False,
            "command_timeout": 300,
            "pip_timeout": 300,
            "max_env_size": "1GB",
        }
        # 合并用户配置
        self.engine_config = {**self.default_config, **config}

    def create_isolation(
        self, path: Path, env_id: str, isolation_config: Dict[str, Any]
    ) -> IsolatedEnvironment:
        """创建Virtualenv隔离环境"""
        # 合并引擎配置和隔离配置
        final_config = {**self.engine_config, **isolation_config}

        env = VirtualenvEnvironment(env_id, path, self, final_config)

        # 创建虚拟环境
        if not env.create_virtualenv():
            logger.error(f"Failed to create virtual environment for {env_id}")
            raise RuntimeError(f"Virtual environment creation failed for {env_id}")

        self.created_environments[env_id] = env
        logger.info(f"Created virtual environment: {env_id} at {path}")
        return env

    def cleanup_isolation(self, env: IsolatedEnvironment) -> bool:
        """清理隔离环境"""
        if isinstance(env, VirtualenvEnvironment):
            success = env.cleanup(force=True)
            if success:
                # 从引擎的创建环境列表中移除
                if env.env_id in self.created_environments:
                    del self.created_environments[env.env_id]
                logger.info(
                    f"Successfully cleaned up virtual environment: {env.env_id}"
                )
            else:
                logger.error(f"Failed to clean up virtual environment: {env.env_id}")
            return success
        else:
            logger.error(f"Invalid environment type for Virtualenv engine: {type(env)}")
            return False

    def get_isolation_status(self, env_id: str) -> Dict[str, Any]:
        """获取隔离状态"""
        if env_id not in self.created_environments:
            return {"status": "not_found", "isolation_type": "virtualenv"}

        env = self.created_environments[env_id]
        status = env.get_status()
        status.update(
            {
                "isolation_type": "virtualenv",
                "supported_features": self.supported_features,
                "engine_config": self.engine_config,
            }
        )

        # 添加Virtualenv特定的属性（如果适用）
        if isinstance(env, VirtualenvEnvironment):
            status.update(
                {
                    "venv_path": str(env.venv_path),
                    "python_path": str(env.python_path),
                }
            )
        return status

    def validate_isolation(self, env: IsolatedEnvironment) -> bool:
        """验证隔离有效性"""
        if isinstance(env, VirtualenvEnvironment):
            is_valid = env.validate_isolation()
            logger.debug(f"Validation result for {env.env_id}: {is_valid}")
            return is_valid
        else:
            logger.error(f"Invalid environment type for Virtualenv engine: {type(env)}")
            return False

    def get_supported_features(self) -> List[str]:
        """获取支持的功能列表"""
        return self.supported_features.copy()

    def get_engine_info(self) -> Dict[str, Any]:
        """获取引擎信息"""
        info = super().get_engine_info()
        info.update(
            {
                "engine_type": "virtualenv",
                "python_version": sys.version,
                "python_executable": sys.executable,
                "engine_config": self.engine_config,
                "venv_module_available": hasattr(venv, "EnvBuilder"),
            }
        )
        return info
